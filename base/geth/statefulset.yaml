apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: geth
spec:
  serviceName: geth
  replicas: 1
  selector:
    matchLabels:
      app: geth
  template:
    metadata:
      labels:
        app: geth
    spec:
      serviceAccountName: geth # Service Account
      terminationGracePeriodSeconds: 60
      volumes:
      - name: env-share
        emptyDir: {}
      - name: git-ssh-auth
        secret:
          secretName: gitlab-repo-ssh-key
          defaultMode: 0o400
      - name: jwtsecret-volume
        secret:
          secretName: jwtsecret
          defaultMode: 0o400
      - name: persistent-storage
        persistentVolumeClaim:
          claimName: efs-claim

      initContainers:
      - name: gitlab-config-cloner
        image: alpine/git:latest
        env:
        - name: REPO_URL
          valueFrom:
            configMapKeyRef:
              name: git-repo-config
              key: GIT_REPO_URL
        - name: GIT_SSH_COMMAND
          value: "ssh -o UserKnownHostsFile=/etc/git-secret/known_hosts -i /etc/git-secret/ssh-privatekey"
            # For git-sync image, you might use its specific env vars like GIT_SYNC_REPO, GIT_SYNC_BRANCH, GIT_SYNC_ROOT, etc.
            # and it handles the SSH key via /etc/git-secret/ssh
        command:
        - /bin/sh
        - -c
        - |
          set -e  # Exit immediately if a command exits with a non-zero status.
          set -x  # Print each command before executing it (for debugging, can be removed in production).

          # Install rsync
          apk add --no-cache rsync

          CONFIG_DIR="/data/config"
          KEYS_DIR="/data/validator-keys"
          #REPO_URL="git@gitlab.com:nontster/ethereum_bootstrap.git"
          TEMP_CLONE_DIR="/tmp/git-repo-clone"
          CONFIG_SUBDIR_IN_REPO="config/metadata"
          KEYS_SUBDIR_IN_REPO="vc/data"

          CLONE_PERFORMED=false
          REPO_CLONED_SUCCESSFULLY=false

          # Ensure target directories exist (they are mount points from the PVC)
          mkdir -p "$CONFIG_DIR"
          mkdir -p "$KEYS_DIR"

          # Function to clone the repository
          clone_repo() {
            if [ ! -d "$TEMP_CLONE_DIR/.git" ]; then # Check if already cloned properly
              echo "Cloning repository $REPO_URL into temporary directory $TEMP_CLONE_DIR..."
              # Clean up any partial clone before attempting a new one
              rm -rf "$TEMP_CLONE_DIR"
              git clone --depth 1 "$REPO_URL" "$TEMP_CLONE_DIR"
              CLONE_PERFORMED=true # Mark that a clone attempt was made
              REPO_CLONED_SUCCESSFULLY=true # Assume success, will be clear on rsync path check
              echo "Repository cloned."
            else
              echo "Repository already cloned to $TEMP_CLONE_DIR."
              REPO_CLONED_SUCCESSFULLY=true # Already successfully cloned
            fi
          }

          # Process /data/config
          echo "Checking configuration directory: $CONFIG_DIR"
          if [ -d "$CONFIG_DIR" ] && [ "$(ls -A $CONFIG_DIR)" ]; then
            echo "Configuration directory $CONFIG_DIR is not empty. Skipping rewrite."
          else
            echo "Configuration directory $CONFIG_DIR is empty or does not exist. Attempting to populate from git."
            clone_repo # Clone only if needed and not already cloned
            if [ "$REPO_CLONED_SUCCESSFULLY" = true ]; then
              REPO_CONFIG_SOURCE_PATH="$TEMP_CLONE_DIR/$CONFIG_SUBDIR_IN_REPO"
              if [ -d "$REPO_CONFIG_SOURCE_PATH" ]; then
                echo "Syncing contents of $REPO_CONFIG_SOURCE_PATH to $CONFIG_DIR using rsync (no delete)..."
                rsync -av "$REPO_CONFIG_SOURCE_PATH/" "$CONFIG_DIR/" # No --delete
                echo "Successfully synced '$CONFIG_SUBDIR_IN_REPO' contents to $CONFIG_DIR."
              else
                echo "Error: Source subdirectory '$REPO_CONFIG_SOURCE_PATH' not found in the cloned repository."
                echo "Configuration directory $CONFIG_DIR will remain empty."
                # Depending on criticality, you might want to exit 1 here if config is essential on first run
                # exit 1
              fi
            else
              echo "Skipping population of $CONFIG_DIR due to repository clone failure."
            fi
          fi

          # Process /data/validator-keys
          echo "Checking validator keys directory: $KEYS_DIR"
          if [ -d "$KEYS_DIR" ] && [ "$(ls -A $KEYS_DIR)" ]; then
            echo "Validator keys directory $KEYS_DIR is not empty. Skipping rewrite."
          else
            echo "Validator keys directory $KEYS_DIR is empty or does not exist. Attempting to populate from git."
            clone_repo # Clone only if needed and not already cloned
            if [ "$REPO_CLONED_SUCCESSFULLY" = true ]; then
              REPO_KEYS_SOURCE_PATH="$TEMP_CLONE_DIR/$KEYS_SUBDIR_IN_REPO"
              if [ -d "$REPO_KEYS_SOURCE_PATH" ]; then
                echo "Syncing contents of $REPO_KEYS_SOURCE_PATH to $KEYS_DIR using rsync (no delete)..."
                rsync -av "$REPO_KEYS_SOURCE_PATH/" "$KEYS_DIR/" # No --delete
                echo "Successfully synced '$KEYS_SUBDIR_IN_REPO' contents to $KEYS_DIR."
              else
                echo "Error: Source subdirectory '$REPO_KEYS_SOURCE_PATH' not found in the cloned repository."
                echo "Validator keys directory $KEYS_DIR will remain empty."
                # Depending on criticality, you might want to exit 1 here if keys are essential on first run
                # exit 1
              fi
            else
              echo "Skipping population of $KEYS_DIR due to repository clone failure."
            fi
          fi

          if [ "$CLONE_PERFORMED" = true ] && [ -d "$TEMP_CLONE_DIR" ]; then
            echo "Cleaning up temporary clone directory $TEMP_CLONE_DIR..."
            rm -rf "$TEMP_CLONE_DIR"
          fi

          echo "Init container 'gitlab-config-cloner' finished processing."
          echo "Final contents of $CONFIG_DIR (ls -la):"
          ls -la "$CONFIG_DIR" || echo "$CONFIG_DIR not listable or empty"
          echo "Final contents of $KEYS_DIR (ls -la):"
          ls -la "$KEYS_DIR" || echo "$KEYS_DIR not listable or empty"

        volumeMounts:
        - name: git-ssh-auth
          mountPath: /etc/git-secret # This is where the secret's keys will appear as files        
          readOnly: true
        - name: persistent-storage
          mountPath: /data

      - name: init-geth
        image: ethereum/client-go
        command: [ "geth" ]
        args:
        - "--datadir=/data/execution-data"
        - "init"
        - "/data/config/genesis.json"
        envFrom:
        # Get CHAIN_ID etc. if needed by init (though not strictly needed here)
        - configMapRef:
            name: env-vars
        volumeMounts:

        - name: jwtsecret-volume
          mountPath: "/secret"
          readOnly: true
        - name: persistent-storage
          mountPath: /data

      containers:
      - name: geth
        image: ethereum/client-go:latest
        command:
        - /bin/sh
        - -c
        args:
        - |
          set -e # Exit on error

          if [ -z "$EXTERNAL_IP" ]; then # This check will now use the value from ConfigMap
            echo "Error: EXTERNAL_IP variable not set from ConfigMap. Cannot start Geth."
            exit 1
          fi
          if [ -z "$EXTERNAL_PORT" ]; then # This check will now use the value from ConfigMap
            echo "Error: EXTERNAL_PORT variable not set from ConfigMap. Cannot start Geth."
            exit 1
          fi

          echo "Starting Geth with --nat=extip:${EXTERNAL_IP} --port=${EXTERNAL_PORT}"
          # Note: ${CHAIN_ID} will be expanded if CHAIN_ID is an environment variable available to this shell.
          # Ensure CHAIN_ID is correctly populated from the envFrom configMapRef.
          exec geth \
            --networkid=${CHAIN_ID} \
            --state.scheme=path \
            --verbosity=3 \
            --datadir=/data/execution-data \
            --nat=extip:${EXTERNAL_IP} \
            --port=${EXTERNAL_PORT} \
            --http \
            --http.addr=0.0.0.0 \
            --http.port=8545 \
            --http.vhosts=* \
            --http.corsdomain=* \
            --http.api=admin,engine,net,eth,web3,debug,txpool \
            --ws \
            --ws.addr=0.0.0.0 \
            --ws.port=8546 \
            --ws.api=admin,engine,net,eth,web3,debug,txpool \
            --ws.origins=* \
            --allow-insecure-unlock \
            --authrpc.port=8551 \
            --authrpc.addr=0.0.0.0 \
            --authrpc.vhosts=* \
            --authrpc.jwtsecret=/secret/jwtsecret \
            --syncmode=full \
            --nodekeyhex=0ad62d8dd53414ff21cc41842c128ccd65231f6d8d537a81f8ff584a2fda7584 \
            --rpc.allow-unprotected-txs \
            --syncmode=snap \
            --metrics \
            --pprof \
            --pprof.addr=0.0.0.0 \
            --pprof.port=6060

        ports:
        - name: http-rpc
          containerPort: 8545
          protocol: TCP
        - name: ws-rpc
          containerPort: 8546
          protocol: TCP
        - name: auth-rpc
          containerPort: 8551
          protocol: TCP
        - name: metrics
          containerPort: 6060
          protocol: TCP
        - name: p2p-tcp
          containerPort: 30303
          protocol: TCP
        - name: p2p-udp
          containerPort: 30303
          protocol: UDP
        envFrom:
        - configMapRef:
            name: env-vars
        env:
        - name: EXTERNAL_IP # The variable name your script expects
          valueFrom:
            configMapKeyRef:
              name: external-network-config # Name of the ConfigMap you created
              key: GETH_EXTERNAL_IP # Key in the ConfigMap data
        - name: EXTERNAL_PORT # The variable name your script expects
          valueFrom:
            configMapKeyRef:
              name: external-network-config # Name of the ConfigMap
              key: GETH_EXTERNAL_PORT
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        volumeMounts:
        - name: jwtsecret-volume
          mountPath: "/secret"
          readOnly: true
        - name: persistent-storage
          mountPath: /data
